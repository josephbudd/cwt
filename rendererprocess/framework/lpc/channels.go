// +build js, wasm

package lpc

import (
	"encoding/json"
	"fmt"
	"syscall/js"

	"github.com/josephbudd/cwt/domain/lpc"
	"github.com/josephbudd/cwt/domain/lpc/message"
)

/*
	DO NOT EDIT THIS FILE.

	USE THE TOOL kicklpc TO ADD OR REMOVE LPC Messages.

	kicklpc will edit this file for you.

*/

// Sending is a channel that sends to the main process.
type Sending chan interface{}

// Receiving is a channel that receives from the main process.
type Receiving chan interface{}

var (
	send    Sending
	receive Receiving
	global  js.Value
	alert   js.Value
)

func init() {
	send = make(chan interface{}, 1024)
	receive = make(chan interface{}, 1024)
	g := js.Global()
	global = g
	alert = g.Get("alert")
}

// Channels returns the renderer connection channels.
func Channels() (sendChan, receiveChan chan interface{}) {
	sendChan = send
	receiveChan = receive
	return
}

// Payload converts unmarshalled msg to the correct marshalled payload.
func (sending Sending) Payload(msg interface{}) (payload []byte, err error) {

	defer func() {
		if err != nil {
			err = fmt.Errorf("sending.Payload: %w", err)
		}
	}()

	var bb []byte
	var id uint64
	switch msg := msg.(type) {
	case *message.LogRendererToMainProcess:
		if bb, err = json.Marshal(msg); err != nil {
			return
		}
		id = 0
	case *message.InitRendererToMainProcess:
		if bb, err = json.Marshal(msg); err != nil {
			return
		}
		id = 1
	case *message.CheckCopyRendererToMainProcess:
		if bb, err = json.Marshal(msg); err != nil {
			return
		}
		id = 2
	case *message.CheckKeyRendererToMainProcess:
		if bb, err = json.Marshal(msg); err != nil {
			return
		}
		id = 3
	case *message.GetCopyWPMRendererToMainProcess:
		if bb, err = json.Marshal(msg); err != nil {
			return
		}
		id = 4
	case *message.GetKeyCodesRendererToMainProcess:
		if bb, err = json.Marshal(msg); err != nil {
			return
		}
		id = 5
	case *message.GetKeyWPMRendererToMainProcess:
		if bb, err = json.Marshal(msg); err != nil {
			return
		}
		id = 6
	case *message.GetTextToCopyRendererToMainProcess:
		if bb, err = json.Marshal(msg); err != nil {
			return
		}
		id = 7
	case *message.GetTextToKeyRendererToMainProcess:
		if bb, err = json.Marshal(msg); err != nil {
			return
		}
		id = 8
	case *message.KeyRendererToMainProcess:
		if bb, err = json.Marshal(msg); err != nil {
			return
		}
		id = 9
	case *message.MetronomeRendererToMainProcess:
		if bb, err = json.Marshal(msg); err != nil {
			return
		}
		id = 10
	case *message.UpdateCopyWPMRendererToMainProcess:
		if bb, err = json.Marshal(msg); err != nil {
			return
		}
		id = 11
	case *message.UpdateKeyCodeRendererToMainProcess:
		if bb, err = json.Marshal(msg); err != nil {
			return
		}
		id = 12
	case *message.UpdateKeyWPMRendererToMainProcess:
		if bb, err = json.Marshal(msg); err != nil {
			return
		}
		id = 13
	default:
		bb = []byte("Unknown!")
		id = 999
	}
	pl := &lpc.Payload{
		ID:    id,
		Cargo: bb,
	}
	payload, err = json.Marshal(pl)
	return
}

// Cargo returns a marshalled payload's unmarshalled cargo.
func (receiving Receiving) Cargo(payloadbb []byte) (cargo interface{}, err error) {

	defer func() {
		if err != nil {
			err = fmt.Errorf("receiving.Cargo: %w", err)
		}
	}()

	payload := lpc.Payload{}
	if err = json.Unmarshal(payloadbb, &payload); err != nil {
		return
	}
	switch payload.ID {
	case 0:
		msg := &message.LogMainProcessToRenderer{}
		if err = json.Unmarshal(payload.Cargo, msg); err != nil {
			return
		}
		cargo = msg
	case 1:
		msg := &message.InitMainProcessToRenderer{}
		if err = json.Unmarshal(payload.Cargo, msg); err != nil {
			return
		}
		cargo = msg
	case 2:
		msg := &message.CheckCopyMainProcessToRenderer{}
		if err = json.Unmarshal(payload.Cargo, msg); err != nil {
			return
		}
		cargo = msg
	case 3:
		msg := &message.CheckKeyMainProcessToRenderer{}
		if err = json.Unmarshal(payload.Cargo, msg); err != nil {
			return
		}
		cargo = msg
	case 4:
		msg := &message.GetCopyWPMMainProcessToRenderer{}
		if err = json.Unmarshal(payload.Cargo, msg); err != nil {
			return
		}
		cargo = msg
	case 5:
		msg := &message.GetKeyCodesMainProcessToRenderer{}
		if err = json.Unmarshal(payload.Cargo, msg); err != nil {
			return
		}
		cargo = msg
	case 6:
		msg := &message.GetKeyWPMMainProcessToRenderer{}
		if err = json.Unmarshal(payload.Cargo, msg); err != nil {
			return
		}
		cargo = msg
	case 7:
		msg := &message.GetTextToCopyMainProcessToRenderer{}
		if err = json.Unmarshal(payload.Cargo, msg); err != nil {
			return
		}
		cargo = msg
	case 8:
		msg := &message.GetTextToKeyMainProcessToRenderer{}
		if err = json.Unmarshal(payload.Cargo, msg); err != nil {
			return
		}
		cargo = msg
	case 9:
		msg := &message.KeyMainProcessToRenderer{}
		if err = json.Unmarshal(payload.Cargo, msg); err != nil {
			return
		}
		cargo = msg
	case 10:
		msg := &message.MetronomeMainProcessToRenderer{}
		if err = json.Unmarshal(payload.Cargo, msg); err != nil {
			return
		}
		cargo = msg
	case 11:
		msg := &message.UpdateCopyWPMMainProcessToRenderer{}
		if err = json.Unmarshal(payload.Cargo, msg); err != nil {
			return
		}
		cargo = msg
	case 12:
		msg := &message.UpdateKeyCodeMainProcessToRenderer{}
		if err = json.Unmarshal(payload.Cargo, msg); err != nil {
			return
		}
		cargo = msg
	case 13:
		msg := &message.UpdateKeyWPMMainProcessToRenderer{}
		if err = json.Unmarshal(payload.Cargo, msg); err != nil {
			return
		}
		cargo = msg
	default:
		errMsg := fmt.Sprintf("no case found for payload id %d", payload.ID)
		err = fmt.Errorf(errMsg)
	}
	return
}
